# LINQ

- LINQ stands for **Language Integrated Query**

- **System.Linq** namespace

- common query syntax which allows us to write structured type-safe queries over local object collections and remote data sources. 

- LINQ's hierarchical data model is more flexible than the grid-like data returned from a SQL query

  - LINQ can return a set of `Customer` objects, each of which owns a set of 0-to-*n* `Orders`. Each `Order` can be associated with a set of `OrderDetails`. 

    ```c#
    //the city in which a customer lives 
    //and a list of the orders the person has made.
    var query = from c in db.Customers
                select new { City = c.City, //c is an instance of a Customer object.
                            // and Customer object is not flat;it contains a set of nested Order objects.
                             orders = from o in c.Orders  //gain acess to the Orders table
                             select new { o.OrderID }
                           };
    ```

    result:  <img src="../../../../resources/image-20210325231548330.png" alt="image-20210325231548330" style="zoom:33%;" />
    
     `Customer` object will be automatically generated by the LINQ to SQL designer. 
    
    ```c#
    //LINQ to SQL automatically gives you a hierarchical view of your data.
    public partial class Customer
    {
         ... 
         private string _CustomerID;
         private string _CompanyName;
         ...
         private EntitySet<Order> _Orders; //bound to the Orders table in a one-to-many relationship, each customer has from 0-to-n orders associated with it,
         ... 
    }
    
    
    public partial class Order
    {
         ... 
         private int _OrderID;
         private string _CustomerID;
         private System.Nullable<int> _EmployeeID;
     	 ...
         private EntityRef<Customer> _Customer; //one-to-one relationship with the Customer table
         ... 
    }
    ```
    
    ```c#
    //LINQ to SQL query:
    var query = from c in db.Customers            
        where c.CompanyName == companyName            
        from o in c.Orders            
        from x in o.Order_Details            
        where x.Product.Category.CategoryName == "Confections"            
        orderby x.Product.ProductName            
        group x by x.Product.ProductName into g            
        orderby g.Count()            
        select new { Count = g.Count(), Product = g.Key };
    
    // if use LINQ’s hierarchical structure
    var query = from c in db.Customers
                from o in c.Orders
                from x in o.Order_Details
        where x.Product.Category.CategoryName == "Confections" 
        // x is an instance of a class containing the data from a row of the Order_Details table, which has a relationship with the Category table, which has a field called CategoryName
    ```
    

- LINQ is declarative, meaning not how, but what

  ```c#
  // imperative style
  // details exactly how to add items to a list.
  List<int> imperativeList = new List<int>();
  imperativeList.Add(1);
  imperativeList.Add(2);
  imperativeList.Add(3);
  
  // declarative style
  List<int> declaractiveList = new List<int> { 1, 2, 3 };
  // another declarative style example
  List<int> list01 = new List<int> { 1, 2, 3 };
  List<int> list02 = new List<int> { 4, 5, 6 };
  List<int> list03 = new List<int> { 7, 8, 9 };
  List<List<int>> lists = new List<List<int>> { list01, list02, list03 };
  ```


- LINQ to Objects queries are composable, because they return type `IEnumerable<T>`

  Take complex problems, break them into manageable pieces, and solve them with code that is easy to understand and easy to maintain.

  ```c#
  var query = from customer in db.Customers
              where customer.City == "Paris"
              select customer;
  
  query2 = from customer in query
          where customer.Address.StartsWith("25")
          select customer;
  ```

- **Discreet Computations and PLINQ**

  each computation returned by a query is discreet, it can easily be run concurrently on its own thread. This has important consequences for a field of study called Parallel LINQ (PLINQ).

  

### Benefits of using LINQ

1. shorter code, less cumbersome

```c#
// old time when querying data:
SqlConnection sqlConnection = new SqlConnection(connectString);
sqlConnection.Open();
System.Data.SqlClient.SqlCommand sqlCommand = new SqlCommand();
sqlCommand.Connection = sqlConnection;
//only from here is directly define the query
sqlCommand.CommandText = "Select * from Customer";
return sqlCommand.ExecuteReader(CommandBehavior.CloseConnection)

    
//LINQ version
Northwind db = new Northwind)(@"C:\Data\Northwnd.mdf");
var query = from c in db.Customers            
    select c;
```

2. a single, unitive syntax can be used to query diverse types of data against diverse APIs. overall syntax, and theory are the same even if some of the details differ.

   • SQL to query a database

   • Web services to access some forms of remote data

   • Looping and branching to query the collections in their own programs



### Basic units of **data in LINQ**

​					    |								

​					**Sequences**   (any object that implements the generic IEnumerable)

​		- **local sequence** (local collection of objects in memory) 

​        - remote sequence (**remote data source** such as SQL server). These sequences additionally implement the IQueryable<> interface and are supported through a matching set of standard query operators in the [Queryable class](https://docs.microsoft.com/en-us/dotnet/api/system.linq.queryable?view=net-5.0).

​						|

​					**Elements** (each element is each item in the sequence)



**Query Operator** is a method that transforms a sequence. There are 50 query operators



### Basic  Syntax

```c#
from elem in collection
where...
orderby ...
select...  //ends with select or group clause
  
foreach...
  
  
names.Where(n=> n.Contains("a"))
  	 .OrderBy(n=> n.Length)
     .Select(n=> n.ToUpper())
```

<img src="../../../../resources/image-20210328104750069.png" alt="image-20210328104750069" style="zoom: 50%;" />

![image](https://learning.oreilly.com/library/view/essential-linq/9780321604750/graphics/t0132-01.jpg)

• The `var` keyword tells the compiler to infer the type returned by a query.



### Query Expressions

![image-20210318210558066](../../../../resources/image-20210318210558066.png)



### LINQ Examples

```c#
// find teenager students
Student[] teenAgerStudents = studentArray
    						.Where(s => s.age > 12 && s.age < 20)
    						.ToArray();
       
// find first student whose name is Bill 
Student bill = studentArray
    			.Where(s => s.StudentName == "Bill")
    			.FirstOrDefault();
        
var query = names
  .Where(name => name.Length > 4)
  .OrderBy(name => name.Length)   // first sort by length
  .ThenBy(name => name);     // then sort by alphabetical order

```



### LINQ Architecture

![image-20210319102005447](../../../../resources/image-20210319102005447.png)

#### LINQ Providers

- LINQ provider is a software component that lies between the LINQ queries and the actual data source. 
- It  implements the **IQueryProvider** and **IQueryable** interface for a particular data source and will convert the LINQ queries into a format that can be understood by the underlying data source.



### Different Ways to Write LINQ Query with Examples

- Linq Query Syntax 

  ```c#
  from object in datasource // initialization
  where condition     // condition
  select object       // selection
  ```

- Linq Method Syntax (most popular and uses a lambda expression)

  ```c#
  DataSource.ConditionMethod().SelectionMethod()
  ```

- Mixed Syntax (Query + Method)

  ```c#
  (from object in DataSource 
  where condition
  select object).Method()
  ```

  

### LINQ has 3 parts:

1. Data Source (in-memory objects, SQL, XML)
2. Query
   1. Initialization (to work with a particular data source)
   2. Condition (where, filter, sorting condition)
   3. Selection (single selection, group selection or joining)
3. Execution of the query

![image-20210318211006355](../../../../resources/image-20210318211006355.png)

- **Extension methods (REQUIRED)**: These include examples such as `Where`, `OrderBy`, and `Select`. These are what provide the functionality of LINQ.      

- **LINQ providers (REQUIRED)**: These include LINQ to Objects, LINQ to Entities, LINQ to XML, LINQ to OData, and LINQ to Amazon. These are what convert standard LINQ operations into specific commands for different types of data.      

- **Lambda expressions (optional):** These can be used instead of named methods to simplify LINQ extension method calls.      

- **LINQ query comprehension syntax (optional):** These include `from`, `in`, `where`, `orderby`, `descending`, and `select`. These are C# keywords that are aliases for some of the LINQ extension methods, and their use can simplify the queries you write, especially if you already have experience with other query languages, such as Structured Query Language (SQL).



## IEnumerable and IQueryable in C#

### `IEnumerable`

##### What's IEnumerable?

`IEnumerable<T>` is an interface that guarantees a given class is **iterable**. 

<img src="https://dotnettutorials.net/wp-content/uploads/2019/04/c-users-pranaya-pictures-ienumerable-interface-pn.png" alt="c-users-pranaya-pictures-ienumerable-interface-pn" style="zoom:67%;" />

Array, and all generic collections, such as `List<T>, Dictionary<TKey, TValue>, Stack<T>`, and `Queue<T>`, implement `IEnumerable<T>` can be queried and manipulated with LINQ. They all  implement the `IEnumerable<T>` class.

<img src="https://dotnettutorials.net/wp-content/uploads/2019/04/c-users-pranaya-pictures-generic-ienumerable-inte.png" alt="c-users-pranaya-pictures-generic-ienumerable-inte" style="zoom:60%;" />



### `IQueryable`

##### What is IQueryable in C#?

A simple interface with only 1 method: enable for each loop on a given object

<img src="../../../../resources/image-20210320105551319.png" alt="image-20210320105551319" style="zoom: 50%;" />

 **IQueryable** is an interface and it is available in **System.Linq** namespace.

It is also a child of the IEnumerable interface. So we can store IQuerable in a variable of type IEnumerable. 

`IQueryProvider`

![c-users-pranaya-pictures-iqueryprovider-interface-768x225](https://dotnettutorials.net/wp-content/uploads/2019/04/c-users-pranaya-pictures-iqueryprovider-interface-768x225.png)

The methods provided by the **IQueryProvider** are used to create all Linq Providers. So, this is the best choice for other data providers such as **Linq to SQL, Linq to Entities**, etc.



Diffs between **IEnumerable** & **IQueryable**

| IEnumerable                                             | IQueryable                                                   |
| ------------------------------------------------------- | ------------------------------------------------------------ |
| in-memory collections like List, Array, etc             | out-memory such as remote database, service, etc.            |
| mostly used for LINQ to Object and LINQ to XML queries. | mostly used for LINQ to SQL and LINQ to Entities queries.    |
| doesn’t support custom queries.                         | supports custom queries using CreateQuery and Executes methods. |
| doesn’t support lazy loading.                           | supports lazy loading and hence it is suitable for paging like scenarios. |



## Delegates (variable)

- declaring a variable that references an individual method.

- Because the delegate is just a variable, you can pass it to other methods and perform similar tricks with it that would otherwise be impossible.

  ```c#
  using System;
  namespace SimpleLambda
  {
      class Program
      {
          //defines a delegate type that has the same signature as the Add method.
          public delegate int MyDelegate(int a, int b);
          public static int Add(int a, int b)
          {
              return a + b;
          }
          public static void CallDelegate(MyDelegate Func) // Func = myDelegate
          {
              Console.WriteLine(Func(272, 153));
          }
          static void Main(string[] args)
          {
              MyDelegate myDelegate = Add; // assign the Add method to an instance of MyDelegate. it works because they have the same parameter types and same return type
              Console.WriteLine(myDelegate(271, 152));
              CallDelegate(myDelegate);
          }
      }
  }
  ```

##### Generic Delegates

```c#
//before
public delegate int MyDelegate(int a, int b);

//now
public delegate TResult MyDelegate<T1, T2, TResult>(T1 a, T2 b);

MyDelegate<int, int, int> myDelegate = Add;
```



## Lambda

```c#
// "a and b goes to a plus b"
Func<int, int, int> myLambda = (a, b) => (a + b);

||
    
public static int Add(int a, int b){    
    return a + b;
}        
Func<int, int, int> myDelegate = Add;

||

// anonymous method
Func<int, int, int> myAnonMethod = delegate(int a, int b)
{
    return a + b;
};
```



## Extension Method

use static method to add functionality of the xx(e.g., string) class

```c#
namespace ExtensionMethods
{
    public static class IntExtensions // MUST BE static class
    {
       // MUST BE static method, and add this 
        public static bool IsGreaterThan(this int i, int value)
        {
                    return i > value;
        }
    }
}
```

From the developer’s perspective, it appears to be like an instance method of type `string`, but behind the scenes it is a static method call: `SpecialString.IsState(myString)`.



##### Points to Remember :

1.  The class must be declared to be `static`.

2. The extension method must also be static.

3. The first parameter of an extension method must include the `this` modifier, and it cannot be a pointer type.

4.  Extension methods cannot appear in generic classes.

5. Extension methods can be used anywhere in the application by including the namespace of the extension method.

6. scoping issues

   -  **instance method is always called before an extension method.** Hence, the extension method may never be called, unless you explicitly call it as a static method of `MyExtensions01`

     ```c#
     using System;
     namespace ConsoleApplication1
     {
         public class MyClass
         {
             public void DoThis()
             {
                 Console.WriteLine("MyClass.DoThis");
             }
         }
     
         public static class MyExtensions01
         {
             // Can never be called as if it were an instance method
             // of MyClass.
             public static void DoThis(this MyClass myClass)
             {
                 Console.WriteLine("MyExtensions01.DoThis");
             }
         }
     
         class Program
         {
             static void Main(string[] args)
             {
                 MyClass myClass = new MyClass();
                 myClass.DoThis();                // Calls MyClass.DoThis
                 MyExtensions01.DoThis(myClass);  // Calls
                                                  // MyExtensions01.DoThis
             }
         }
     }
     ```

   - if two extension methods with the same name

     - if they both in the same namespace or different namespaces, it will be a problem.

     **solution:**

     - You could explicitly state which method you want to call using standard static syntax: `MyExtensions01.DoThat(m)`.

     - You could move either `MyExtensions02` or `MyExtensions01` into the `ExtensionScope` namespace

       

##### Place Your Extensions in a Separate File, and Give Them a Unique Namespace

```c#
namespace MyCode
{
   ... Code omitted here
}

namespace MyCode.Extensions
{
     public static class SpecialString
   {
      private static string[] stateCodes =
           {"AL","AK","AZ","AR","CA","CO","CT","DE","FL",
            "GA","HI","ID","IL","IN","IA","KS","KY","LA",
            "ME","MD","MA","MI","MN","MS","MO","MT","NE",
            "NV","NH","NJ","NM","NY","NC","ND","OH","OK",
            "OR","PA","RI","SC","SD","TN","TX","UT","VT",
            "VA","WA","WV","WI","WY"};

      public static bool IsState01(this string source)
      {
         if (source == null) return false;
         source = source.ToUpper();
         foreach (var item in stateCodes)
         {
            if (source == item)
            {
               return true;
            }
         }
         return false;
      }
   }
}

//Accessing Extension Methods in a Namespace
using System;
using MyCode;
using MyCode.Extensions;

namespace ConsoleApplication1
{
    class Program
    {
        static void Main(string[] args)
        {
            MyCode myCode = new MyCode();
            ... // Use My Code here.
            string test = "WA";
            if (test.IsState())
            {
                Console.WriteLine("{0} is a state", test);
            }
        }
    }
}
// we can use LINQ Contains operator
```



##### **When to use Extension Methods in C#?**

You need to use an extension method if any of the following conditions are true:

1. You need a method on an existing type and you are not the owner of the source code of that type.
2. You need a method on an existing type, you do own the source code of that type but that type is an interface.
3. You need a method on an existing type, you do own the source code and that type is not an interface but adding the method creates undesired coupling.



### Forcing Immediate Execution

- ToList,ToArray, ToDictionary, ToLookup 
- Operators that return a single element
  - FirstOrDefault
  - aggregate function (count,max,min,avg)

```c#
var list = new List<int> { 1, 2, 3 };

static void Main(string[] args)
{
    var list = GetList();
    int bound = 3;
    var query = from num in list
                where num < bound
                select num;
    bound = 4;
    foreach (var item in query)
    {
        Console.WriteLine(item); // this will print 1,2,3       not 1,2
        //bound=4 when the code reaches the foreach loop, and that is when the query expression is executed.
    }
}
```

 Only operators that must be called using query method syntax might execute immediately. For instance, when you call `First()` or `ToList()`, execution is immediate



### LINQ Everywhere

LINQ Extender

LINQ over C# project

LINQ to Active Directory

LINQ to Amazon

LINQ to Bindable Sources

LINQ to CRM

LINQ to Excel

LINQ to Expressions

LINQ to Flickr

LINQ to Geo

LINQ to Google

LINQ to Indexes

LINQ to `IQueryable`

LINQ to JavaScript

LINQ to JSON

LINQ to LDAP

LINQ to LLBLGen Pro

LINQ to Lucene

LINQ to Metaweb

LINQ to MySQL

LINQ to NCover

LINQ to NHibernate

LINQ to Opf3

LINQ to Parallel (PLINQ)

LINQ to RDF Files

LINQ to Sharepoint

LINQ to SimpleDB

LINQ to Streams

LINQ to WebQueries

LINQ to WMI



### Reference

https://dotnettutorials.net/lesson/introduction-to-linq/

https://www.tutlane.com/tutorial/linq