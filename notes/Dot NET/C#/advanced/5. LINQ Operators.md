# LINQ Operators

### Categories 

1. Projecting
   1. `Select`
   2. `SelectMany`
2. Ordering 
   1. `OrderBy`, `OrderByDescending`
   2. `ThenBy`, `ThenByDescending`
   3. `reverse`
3. Filtering 
   1. `Where`
   
   2. Take and Skip
   
      1. `take` the first x elements, discarding the rest
   
         similar to sql TOP n
   
      2. `skip` ignores the first x elements, and outputs the rest
   
         Similar to sql ...NOT IN (select TOP n ...)
   
   3. TakeWhile and SkipWhile
   
      1. `TakeWhile` 
   
         emits elements from the input sequence until the predicate is true
   
      2. `SkipWhile`
   
         ignore elements from the input sequence until the predicate is true, then emits the rest
   
   4. `Distinct`
4. Set Operators
   1. `Concat` and `Union`
   2. `Intersect` and `Except`
5. Conversion Methods
   1. `OfType` and `Cast`
   2. `ToArray`, `ToList`, `ToDictionay`, `ToLookup`
   3. `AsEnumerable` and `AsQueryable`
6. Grouping Operators
   
   1. `Join` and `GroupJoin`
8. Element Operators
   1. `FistOrDefault`, `LastOrDefault`,`SingleOrDefault`
   2. `ElementAt`, `ElementAtOrDefault`
   3. `DefaultEmpty`
9. Aggregation Operators
   1. `Count` and `LongCount`
   2. `Min` and `Max`
   3. `Sum` and `Average`
   4. `Aggregate`
10. Quantifiers
    1. `Contains` and `Any`
    2. `All` and `SequenceEqual`
11. Generation Operators
    1. `Empty`
    2. `Range` and `Repeat`
12. Custom Sequence Operators
13. Miscellaneous Operators



## `Select` (Projection)

When the `select` clause produces something other than a copy of the source element, the operation is called a *projection*. 

##### Select 

- query the database column

  ```c#
  IEnumerable<Employees> getEmployees=(from emp in Employees 
                                       select emp); //query
  getEmployees.Dump();   //execution
  
  
  // OR
  var data =Employees.Select(e=>e.LastName + " " + e.FirstName);
  data.Dump();
  ```

- query the object properties

  ```c#
  //Using Query Syntax
  List<Employee> basicQuery = (from emp in Employee.GetEmployees()
                               select emp)
      						.ToList();
  foreach (Employee emp in basicQuery)
  {
      Console.WriteLine($"ID : {emp.ID} Name : {emp.FirstName} {emp.LastName}");
  }
  
  //Using Method Syntax
  IEnumerable<Employee> basicMethod = Employee.GetEmployees().ToList();
  foreach...
  ```

##### Select specify columns

- query the database column

  Here we use `new` keyword to create an anonymous type.

  ```c#
  var getEmployees=from emp in Employees 
                  select new
             	   {
                  FistName = emp.FirstName, 
                  Title = emp.Title
                 }; //query
  getEmployees.Dump();   //execution
  ```

- query the object properties

  ```c#
  //Using Query Syntax
  List<int> basicPropQuery = (from emp in Employee.GetEmployees()
                              select emp.ID)
     							 .ToList();
  foreach (var id in basicPropQuery)
  {
      Console.WriteLine($"ID : {id}");
  }
  
  //Using Method Syntax
  IEnumerable<int> basicPropMethod = Employee.GetEmployees()
      .Select(emp => emp.ID);
  
  foreach...
  ```

##### Select Data to another class

- query the object properties

  ```c#
  //Query Syntax
  IEnumerable<EmployeeBasicInfo> selectQuery = (from emp in Employee.GetEmployees()
                                                select new EmployeeBasicInfo()
                                                {
                                                    FirstName = emp.FirstName,
                                                    LastName = emp.LastName,
                                                    Salary = emp.Salary
                                                });
  foreach (var emp in selectQuery)
  {
      Console.WriteLine($" Name : {emp.FirstName} {emp.LastName} Salary : {emp.Salary} ");
  }
  //Method Syntax
  List<EmployeeBasicInfo> selectMethod = Employee.GetEmployees().
      Select(emp => new EmployeeBasicInfo()
             {
                 FullName = emp.LastName + " " + emp.LastName,
                 Salary = emp.Salary * 12
             }).ToList();
  foreach...
  ```

- Indexed projection

  ```c#
  string[] words = { "one", "two", "three" };
  var result = words.Select((w, i) => new
                            {
                                Index = i,
                                Value = w
                            });
  ```

##### select subqueries

```c#
// not efficient. need to avoid and use join instead, see the join section
// because for every outer query, the inner element must be enumeratged to get the few matching combinations.
var query = from c in dataContext.Customers
    select new {
    c.Name,
    Purchases = from p in c.Purchases
                where p.Price > 1000
                select new {p.Description, p.Price}
};

//another way to write
from c in dataContext.Customers
let highValueP = from p in c.Purchases
                where p.Price>1000
                select new {p.Description, p.Price}
where highValueP.Any()
select new {c.Name, Purchases = highValueP};
```



### `SelectMany` 

Flattens collections into a single collection (similar to cross join in SQL).

- use for cross join

  ```c#
  string[] fruits = { "Grape", "Orange", "Apple" };
  int[] amounts = { 1, 2, 3 };
  
  var result = fruits.SelectMany(f => amounts, (f, a) => new
                                 {
                                     Fruit = f,
                                     Amount = a
                                 });
  ```
  
  output:
  
  ```
  Grape, 1
  Grape, 2
  Grape, 3
  Orange, 1
  Orange, 2
  Orange, 3
  Apple, 1
  Apple, 2
  Apple, 3
  ```
  
- use for flatten output sequence 

  

## Filtering Operators

#### `Where`

Two overloaded version of "where"

![Where Filtering Operators in LINQ](https://dotnettutorials.net/wp-content/uploads/2019/05/c-users-pranaya-pictures-where-extension-method-s.png)

The 2nd one Func<TSource, **int**, bool> predicate  // int represents the index position of the source element.

##### Single `where`

string: `Contains`, `StartsWith`, `EndsWith`

- query the database column

  ```c#
  var data = Employees.Where(e=> e.LastName.EndsWith("g")
    									.Select(e=>e.FirstName + " " + e.FirstName)
  ```

- query the object properties

  ```c#
  //Query Syntax
  var QuerySyntax = from employee in Employee.GetEmployees()
  where employee.Salary > 50000
  select employee;
  //Method Syntax
  var MethodSyntax = Employee.GetEmployees()
  .Where(emp => emp.Salary > 50000);
  ```

##### `where` + method(s)

```c#
// Create the query with a method call in the where clause.
// Note: This won't work in LINQ to SQL unless you have a
// stored procedure that is mapped to a method by this name.
var queryEvenNums =
    from num in numbers
    where IsEven(num)
    select num;

//Method Syntax
IEnumerable<int> filteredData = intList.Where(num => IsEven(num));
```

##### Multiple Conditions + anonymous type

```c#
//Query Syntax
var QuerySyntax = (from employee in Employee.GetEmployees()
                   where employee.Salary >= 50000 && employee.Technology != null
                   select new {
                       EmployeeName = employee.Name,
                       Gender = employee.Gender,
                       MonthlySalary = employee.Salary / 12
                   }).ToList();
            
//Method Syntax
var MethodSyntax = Employee.GetEmployees()
    .Where(emp => emp.Salary >= 50000 && emp.Technology != null)
    .Select(emp => new {
        EmployeeName = emp.Name,
        Gender = emp.Gender,
        MonthlySalary = emp.Salary / 12
    })
    .ToList();
```



### `Take ` , `Skip`

- query the database column

  ```c#
  var data = Products.Select(p=> p.ProductName.Contains("Chef"))
    															.Distinct()
    															.OrderByDescending(p=> p.ProductName)
    															.Skip(3)
    															.Take(2);
  ```

### `TakeWhile`, `SkipWhile`

- `TakeWhile`

  emitting each item until the given predicate is true.

  ```c#
  int[] numbers = { 3,5,2,234,4,1};
  var result = numbers.TakeWhile(n => n < 100); // result: 3,5,2
  ```

  

- `SkipWhile`

  skip elements until the given predicate is true. then emit that element and the remaining elements

  ```c#
  int[] numbers = { 3,5,2,234,4,1};
  var result = numbers.TakeWhile(n => n < 100); // result: 234,4,1
  ```



### `OfType `

```c#
// basic syntax
public static IEnumerable<TResult> OfType<TResult>(this IEnumerable source);
```

```c#
// example
List<object> dataSource = new List<object>(){
    "Tom","Mary",50,"Prince","Jack",10,20,30,40,"James"
};

List<int> intData = dataSource.OfType<int>().ToList();
```

There is no such `OfType` operator available in query syntax. Instead “is” operator is available.

<!--'Table<Products>' does not contain a definition for 'ofType'-->



